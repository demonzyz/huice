
									Python
-----------------------------------------------------------------------------------------------------------------------
知识块1：配置与运行

环境配置
	   在绝大多数linux和 UNIX系统安装中（包括Mac OS X）,Python的解释器就已经存在了
	   验证方式：命令行输入python--显示版本信息  --交互式解释器(输入exit()退出)
	   python安装
	   	官网：https://www.python.org/
	   	下载对应版本安装包
	   		windows 下载安装包：一路next-->把python的安装目录添加到path系统变量中即可
	   		linux 下载源码包，tar解压-->根目录下运行./configure（加载配置，生成makefile文件）-->make(编译)-->make install(安装)
	   			python还是系统的默认版本
	   				第一步：mv /usr/bin/python /usr/bin/python2.6           //备份老版本
	   				第二步：ln -s /usr/local/bin/python2.7 /usr/bin/python  //系统默认python指向新安装的python27

	    IDE安装与使用
	    	IDLE--Python软件包自带的一个集成开发环境			
	    	pycharm

python的运行原理
	python是脚本语言，直接执行？不需要编译？运行效率高？
	什么是脚本语言？
		文本--html（超文本）浏览器可以顺序解析的特殊文本 --Java、C++(高级编程语言)
		介乎于两者中间的一种编程语言
			1.没有高级编程语言复杂、严谨的语法和规则
			2.有高级的数据结构，如列表和字典结构。但操作简单
		优点：编写简单、高效
		缺点：运行效率低，性能差

	回顾一下java程序的运行过程
		Java首先是通过编译器将.java编译成平台无关的字节码.class文件
		然后在运行时通过解释器，解释成机器文件（被java虚拟机翻译成本地的机器码）--运行
		所以我们说Java是一种先编译后解释的语言，也叫基于虚拟机的语言
		.java-->(javac)-->.class（字节码）-->(java)-->结果

	其实Python和Java/C#一样，也是一门基于虚拟机的语言(先编译后解释)
		解释器类型
			CPython
			PyPy--对Python代码进行动态编译，提高代码的执行速度
			Jython--运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行

		python： .py  -->.pyc文件 --> 执行（解析）-->结果  ?

		运行过程
		python： .py  -->(编译器)-->内存中建立PyCodeObject-->(虚拟机)-->结果-->选择是否 将PyCodeObject写回到.pyc文件中

		引入pyc的目的是省去重复编译的过程---pyc的目的是重用
			我们从实际情况出发，思考下我们在什么时候才可能运行python xxx.py文件
				执行一个程序脚本
				开启一个Web进程时
			基本都是入口文件（程序）或者类似于守护进程，没有多次重复使用的需求 --不添加pyc
			Python的解释器认为：只有import进来的模块，才是需要被重用的模块	   --添加pyc

	总结：真实运行原理
		当python程序运行时，编译的结果则是保存在位于内存中的PyCodeObject中
		当Python程序运行结束时，Python解释器将PyCodeObject选择性地写回到pyc文件中
		当python程序第二次运行时，首先程序会在硬盘中寻找pyc文件，如果找到，则直接载入(?)，否则就重复上面的过程
		每次在载入之前都会先检查一下py文件和pyc文件保存的最后修改日期，如果不一致则重新生成一份pyc文件

	手动编译 
	   单个编译
	   		import py_compile 
	   		py_compile.compile(r'filepath')
	   		或者python -m py_compile filepath
	   	批量编译
	   		import compileall
			compileall.compile_dir(r'filespath')
			或者python -m compileall filespath

	   作用：.pyc执行效率更高，而且看不到源代码 相当于jar包中的.class文件		

	tips:直接运行py文件
		在Windows上是不行的。在Mac和Linux上:
			方法是在.py文件的第一行加上：
				#!/usr/bin/env python
			然后，通过命令加上all的执行权限
				$ chmod a+x hello.py
			就可以直接运行hello.py了   
				hello.py
----------------------------------------------------------------------------------------------------------------------
知识块2：一些琐碎的基本常识
	缩进与行
		Java的语句块是根据{}包裹的
		Python是完全依赖于缩进
			编辑器对缩进的处理各异
				notepad一个tab=4个space，pycharm一个tab=8个space		
			忌讳：混用tab的空格，混用编辑器
			推荐：使用唯一的缩进方式（推荐空格--坚持使用4个空格的缩进），使用固定和统一的编辑器
			tips：解决linux服务器执行脚本异常
				  原因：
				  1.缩进问题，在windows用notepad++显示空格和制表符，统一处理
				  2.在window中行结尾符为'\r\n'表，而在linux中行结尾符为'\n'，而^M 就是是ascii中的'\r'
				  	sed -i 's/^M//g'  filename
		跨行
			'\'可以将两个相邻的物理行连接成一个逻辑行	
			三重引号--定义字符串 
			数据结构赋值	 

	注释
		行注释 #
		区域注释 三重引号'''   '''或者 """  """
		特殊注释
			1.脚本语言共同遵守的规则--当首行为 #! 指定执行本脚本的解释器,如linux shell的#!/bin/sh 
			#! /usr/bin/python
			2.声明文件编码格式的注释
				Python2默认使用ASCII编码，Java默认为Unicode（utf-16）
			# coding=utf-8  中间别有空格
			# -*- coding: utf-8 -*

	大小写敏感
----------------------------------------------------------------------------------------------------------------------
知识块3：变量与数据类型

		程序运行的本质是存储和运算数据

		Python的内存管理机制
			动态类型
				变量的类型和内存都是在运行时确定的。不需要声明，赋值以后该变量才会被创建
				Java  int a = 1；int b = 1；
				Python a = 1; b = 'huice';
				内置函数id():返回对象的地址
				is关键字:判断两个引用所指向的对象是否相同

				对于数字、字符串、布尔值、元组
					a = 1 ; a = 2
					赋值语句，只是创造了新的引用，而不是对象本身
					对象是独立的个体，变量只是他身上的一个个引用
				其它对象
					赋值语句创建出新的对象

			引用计数--指向对象的引用数量
				引用计数增加
					1.对象被创建：x=4
					2.被赋值给其它变量：y=x
					3.被作为参数传递给函数：foo(x)
					4.作为容器对象的一个元素：a=[1, x, ‘33’] 
				引用计数减少 
					1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1
					2.对象的一个别名被赋值给其他对象 x=789 

			垃圾回收
				当某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了

			总结：在Python中变量就是变量，是内存地址指针，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型。类 
			      似于其他java的引用类型

		Python的内置数据类型
			不可变类型：内存中的那块内容的值不可以被改变。如果重新赋值，就等于创建出一个新的对象
			内置函数type() ：对象数据类型查询方法
				数字
					整数  --32位4个字节，64位8个字节  
					长整数  --不限长度(与计算机支持的虚拟内存大小有关)  后加L
					浮点数  --双精度8个字节 
					类型转换
						自动类型转换
							float>long>int
							运算时，转换成最高的级别
						强制类型转换
							int（X）转换X到一个普通整数
							long（X）转换X到一个长整数
							float（X）转换X到浮点数字
							chr（X） 将一个整数转换为可对应ASCII的字符
							ord（X） 将一个字符转换为对应的ASCII码数值   
							一样会存在精度丢失的问题
				布尔值
					True、False--注意大小写
				字符串
					 'ABC'  "ABC"
					 str(x)将对象 x 转换为字符串
					 转义字符：
					 	作用：1.有一类特殊字符是无法表示的
					 			换行 \n
					 			回车 \r
					 		  2.有一些特殊字符，需要使用其自身的含义
					 			'''  --> '\''	
					 			" "a" " --> " \"a\" "
					    常用的转义符：
					    	  \n 	换行
							  \r 	回车
						      \t 	横向制表符	
						      \\	代表一个反斜线字符''\'
							  \'	代表一个单引号（撇号）字符
							  \"	代表一个双引号字符
							  \?	代表一个问号

						r的应用
							字符串前加r，代表忽略内部的转义字符

				元组（Tuple）

			可变类型：内存中的那块内容的值是可以改变的。也不能直接进行新的赋值操作
					  可变只是对于类似于append、+=等这种操作
				列表（List）
				字典（Dictionary）

            空值  None 
            	None有自己的数据类型NoneType
            	None表示一个空对象，没有方法和属性
				不是0、False、空字符串
            	None和任何其他的数据类型比较永远返回False
            	如果函数无return，则默认返回None
----------------------------------------------------------------------------------------------------------------------
知识块4：运算符
		算术运算符
			** 对运算符进行指数(幂)计算		a ** b，表示10的21次幂
			// 地板除
			   操作数的除法，其结果是删除小数点后的商数
			   但如果其中一个操作数为负数，则结果将被保留，即从零(向负无穷大)舍去

		比较(关系)运算符--返回值为布尔值
			== 等于 - 比较对象的值是否相等
					is 两个引用所指的对象是否相同
					注意可变类型和不可变类型的区别
			不等于 != 或 <>
		赋值运算符
			=
			+=
			-=
			*=
			/=
			%=
			**=
			//=
			连续赋值
				a=b=c=1
				a,b,c=1,2,3
 				a,b=b,a //值互换

		逻辑运算符
			and or not 
			注意：短路逻辑

		成员运算符
			in  	如果在指定的序列中找到一个变量的值，则返回true，否则返回false
			not in  如果在指定序列中找不到变量的值，则返回true，否则返回false
			应用：查看字符串中是否含有某个值
				print 'e' in 'hello'
				print 'll' in 'world'
		身份运算符
			is ，is not

		三目运算符
			Java：判定条件?为真时的结果:为假时的结果
				  C= A>B ? 100 :200; 
			Python：为真时的结果 if 判定条件 else 为假时的结果  
				  1 if 5>3 else 0
		++ 和 --
			Python不支持
----------------------------------------------------------------------------------------------------------------------
知识块5：字符串和编码
	字符串的定义--赋值
		单引号、双引号、混用：可以避免使用转义字符
		长字符串--当字符串跨行
			'''  """
		str()	一般是将数值转成字符串
		repr()  将一个对象转成字符串显示--原始值

	字符集与编码格式
		计算机存储的文本-->数字-->二进制数
		字符---对应一个数字（10进制或16进制）---对应二进制数
			支持你存什么字符：字符集
			每一个字符怎么去对应数字：编码格式
				ASCII:
					最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号
					1个字节
					A的编码是65，a的编码是97，小写字母z的编码是122	

				GBXXXX:
					处理中文
					2个字节--65535 
						原本ASCII有的字符
						7000多个简体汉字
						数学符号、罗马希腊的字母、日文的假名
					GB2312---GBK(扩展)

				Unicode
					把所有语言都统一到一套编码里
					最大4个字节
					如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间

				2字节表示一个字符 UTF-16
				4字节表示一个字符 UTF-32

				UTF-8
					可变长编码
					UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节
						常用的英文字母被编码成1个字节，汉字通常是3个字节

				Python3.0之前默认使用ASCII编码，3.0后改用Unicode编码
			
				需要把普通的ASCII编码存储的字符串变成utf-8编码的字符串
					 关键字：u

				在做编码转换时，通常需要以unicode作为中间编码
					decode的作用是将其他编码的字符串转换成unicode编码
					encode的作用是将unicode编码转换成其他编码的字符串

	格式化
		我们经常会输出类似'亲爱的xxx你好！你xx月的话费是xx，余额是xx'之类的字符串，而xxx的内容都是根据变量变化的
		在Python中，采用的格式化方式和C语言是一致的，用%实现
			在字符串内部，%？代表此处的内容需要被变量填充
				数据类型不同
					%s	字符串
						如果字符串中有% 就用%%
					%d	整数
					%f	浮点数
						格式化整数和浮点数还可以指定整数与小数的位数 '%.2f'
					%x	十六进制整数
					%r 原始字符串 --注意和%s的区别
					如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串
			在字符串外部，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略

			格式：' xxx%s,"%d" '%('aaa', 123)

	常用属性和操作
		在Python中，最基本的数据结构是序列
			序列中的每个元素被分配一个序号――即元素的位置，也称为索引
			第一个索引是 0，第二个则是 1，以此类推
			序列中的最后一个元素标记为 -1，倒数第二个元素为 -2
			6种内建的序列，包括列表、元组、字符串、Unicode字符串、buffer对象和xrange对象
			“字符串其实就是一个字符元素组成的序列”
		长度
			内置方法len(string)
		索引和分片
			索引：string[index]
				超出索引：IndexError: string index out of range
				遍历字符串中的每个字符
					0到len-1
				翻转输出每个字符
				    -1 到 -len

			分片（截取）
				格式：string[头下标:尾下标:步长]
					步长默认为1
					越界不会报错,取到结尾
					包含头下标，不包含尾下标
					头下标为空：从第一个字符开始截取
					尾下标为空：截取到最后
					[:]字符串“拷贝”

			字符串翻转
				[::-1]

		字符串连接
			+
				1.Java中其他基本数据类型和string做+，自动转成string处理
				  Python中没有此特性。需要先转成string再做拼接
				2.每连接一次，就要重新开辟空间，然后把字符串连接起来，再放入新的空间
				  大量字符串拼接时，效率低
			join
				'sep'.join(seq)
				上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串

			*加号连接效率低是在连续进行多个字符串连接的时候出现的，如果连接的个数较少，加号连接效率反而比join连接效率高

			格式化
				参考前文

			format
				str.format(text) 
				str中包含占位符，text中是要填充的内容
					使用'{}'占位符
					使用'{0}','{1}'形式的占位符
					使用'{name}'形式的占位符
		字符串替换
			str.replace(old, new[, max])
			参数：old -- 将被替换的子字符串。
         		new -- 新字符串，用于替换old子字符串。未找到就不替换
         		max -- 可选字符串, 替换不超过 max 次

		字符串比较
			cmp() 函数--Python3 中，cmp() 函数被移除了
			cmp(x,y) 函数用于比较2个对象，如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1

		字符串查找
			find
				str.find(target, [start,end) )
				在字符串中查找指定字符串首次出现的index，找不到时返回-1
			index
				str.index(target, [start,end) )
				在字符串里查找子串第一次出现的位置,找不到子串会抛出异常

		字符串分割
			str.spilt(sep, [,max])
				将一个字符串分裂成多个字符串组成的列表
					不带参数时以空格进行分割
					代参数时，以该参数进行分割
					未查询到分隔符时，列表只包含原始字符串

		字符串大小写
			str.upper() --转大写
			str.lower() --转小写
			str.capitalize() --首字母大写
			str.istitle() --是否是首字母大写的
			str.isupper() --字母是否全是大写
			str.islower() --字母是否全是小写 

		字符串去空格	
			str.strip()  --去掉字符串的左右空格
			str.lstrip() --去掉字符串的左边空格
			str.rstrip() --去掉字符串的右边空格

		其他
			str.isalnum() --是否全是字母和数字，并至少有一个字符
			str.isalpha() --是否全是字母，并至少有一个字符
			str.isdigit		  --是否全是数字，并至少有一个字符
			str.isspace() --是否全是空白字符，并至少有一个字符
			str.count(targer,[min,max))   --统计某个字符在字符串中出现的次数
			endswith(target)  --判断字符串是否以某个字符串结尾
			
	eval函数--将字符串str当成有效的表达式来求值并返回计算结果
			  执行动态代码
			  注意安全问题
-----------------------------------------------------------------------------------------------------------------------
知识块6：输入和输出
	print
		Python3.x时代，print必须使用括号（）
		Python2.x时代不是一个函数，只是一个关键字
			输出内容
				1. 字符串和数值类型
				2.变量--无论什么类型，数值，布尔，列表，字典...都可以直接输出
			换行
				print语句默认的会在后面加上换行，加了逗号之后换行就变成了空格 

			小练习：用python输出一个简单的旋转风车，模拟等待图标

	input 
		input(提示信息)输入内容必须是一个合法的Python表达式
		如果是字符串，需要加''或""

	raw_input
		raw_input(提示信息),将所有输入作为字符串看待

	input() 本质上还是使用 raw_input() 来实现的，只是调用完 raw_input() 之后再调用 eval() 函数

-----------------------------------------------------------------------------------------------------------------------
知识块7：控制语句

	分支语句
		第一种：
			if 条件表达式:
		 		条件表达式为真时，执行此代码块

		 	if判断条件还可以简写，比如：
				if x:
    				print 'True'
    			只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False

		第二种:
			if 条件表达式:
				条件表达式为真时，执行此代码块
			else:
				条件表达式为假时，执行此代码块
		第三种:
			if 条件表达式A:
				条件表达式为真时，执行此代码块
			elif 条件表达式B:
				条件表达式B为真时，执行此代码块
		第四种:
			if 条件表达式A:
				条件表达式为真时，执行此代码块
			elif 条件表达式B:
				条件表达式B为真时，执行此代码块
			elif 条件表达式C:
				条件表达式C为真时，执行此代码块
			else:
				以上表达式都为假时，执行此代码块

		注意：1.如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else
			  2.Python中没有switch语句，所以多个条件时，可以用elif来实现

    	练习：
    		根据输入的月份来输出，这个月有几天(默认2月有28天，不考虑闰年)

	循环语句
		while循环，只要条件满足，就不断循环
			 while 条件表达式:
				条件表达式为真时执行代码

		for 循环
			第一种：for in 序列。通过序列项迭代，类似于Java中的for each
				list、tuple
				不足：
					如果循环的序列项很多（不方便每项都列出），但是是在一个区间内的
					如果想得到索引下标

			第二种：利用range()和xrange() 迭代
				range()函数，可以生成一个整数序列
					range(start,end,step),step为空默认为1

				通过序列的索引来遍历序列
					for index in range(len(list)):
    					print key,list[index]

    		第三种，同时使用项和索引迭代	
    			enumerate()函数--同时列出数据和数据下标
    			for i,j in enumerate(list):
    					print i,j

    		第四种，循环中使用else语句
    			其他语言中，只在分支语句中才能见到else，
				python循环语句中使用else，代表在循环正常结束后，执行else中的代码块
				循环没有执行完，比如break或者return，else中的代码块不执行

		练习: 分别使用while与for循环输出1-100之间的所有偶数	
		算法：python的冒泡排序

	pass
		pass是占位语句，什么都不做，只是为了保证程序结构的完整性

	break与continue
		break：终止循环语句
		continue：跳出本次循环
-----------------------------------------------------------------------------------------------------------------------
知识块8：元组
	创建元祖
		元组用圆括号表示，对象用逗号分隔
			方式一：(1, 2, 3)
			方式二: 1, 2, 3

		访问元组对象	
			通过索引、分片
			元组中的元素值是不允许修改的--因为tuple不可变，所以代码更安全

		删除元组
			del语句来删除整个元组

		元祖运算符
			+ 连接: tup3 = tup1 + tup2;
			*N 复制并连接: 重复N次 tup3 = tup1 * 3

		元组内置函数
			cmp(tuple1, tuple2)：比较两个元组元素。
			len(tuple)：计算元组元素个数。
			max(tuple)：返回元组中元素最大值。
			min(tuple)：返回元组中元素最小值。
			tuple(seq)：将序列转换为元组。

		元组操作
			index : T.index(value)获取元素在元组中的索引值,对于重复的元素,默认获取从左起第一个元素的索引值
			count : T.count(value)返回元组中某元素的个数

		元组嵌套：
			多维元素: ((1, 2, 3),(4, 5, 6))
				元组虽然不可变，但是当元组中嵌套可变元素时，该可变元素是可以修改的，元组本身不变

		和Java中数组的区别：
			1.定义的时候不需要指定长度和存储的数据类型
			2.不可以修改其中任何一项数据的值
			3.可以追加值但是对象会重新创建
			4.可以嵌套组成多维数据结构

-----------------------------------------------------------------------------------------------------------------------
知识块9：列表
	列表是可变数据类型--可以改变元素的值
	可以保存任何数据类型--数据项不需要具有相同的类型
		创建 [ ] 
		访问数据项
			索引
			分片
		更新数据项
			索引赋值
				不能超过索引范围
			分片赋值
				可以同时改变一个范围内的数据项
				list1[x:y] = list2
					*list2替换后总长度可以和list1不相等
						批量追加
						批量删除
						清空列表	
							list[:] = []
						批量插入 
							list[x:x] = list2 --第x项后插入一个列表，但是要注意区分和索引赋值的区别

		删除数据项
			del list[index]
			del list 不加索引直接删除引用，回收对象

		列表方法
			append  用于在列表末尾追加新的元素
			count   用于统计某个元素在列表中出现的次数
			extend  在列表末尾一次性追加另一个序列中的多个值
			insert(index, obj)		将对象插入到列表指定项
			index   用于从列表中找出某个值第一个匹配项的索引位置
			pop     该方法从列表中弹出一个元素，默认是最后一个。并且返回弹出的元素
			remove  从列表中移除某个值的第一个匹配项。与pop不同的是，该方法并不返回移除的元素
			reverse 该方法对序列方向存放。注意该方法改变了列表但是没有返回值
				reversed函数:并不返回一个列表，而是返回一个迭代器对象，使用list把迭代器对象转换成列表
			sort  用于在原位置度列表进行排序。 在原位置意味着列表会被修改
				  注意:sort()方法的返回值并不是序列本身，而是None
					如何保存原序列顺序而进行排序
						1.拷贝后再排序
						2.函数：sorted(list)
				    如何改排序规则
				    	key和reverse参数的使用
				    		key = 排序规则函数名
				    		reverse 默认为False--按照ASCII码的升序排列，reverse=True降序

			练习：
				1.利用列表实现数据结构--栈
				2.给定一个包含了大小写字母，数字的字符串，对其进行重新排序
					要求：a.小写字母在大写字母前
					      b.字母在数字前
					      c.奇数在偶数前

		迭代
			for x in list: print x
			for x in range(len(list)):
				print x
			[x for x in list] --迭代后自动装填成新列表
				练习：
					1.
					x=[1,2,3,4]  y=[5,6,7,8]
					一行代码输出，一个新列表：是两个list中的偶数分别相加，应该结果是[2+6,4+6,2+8,4+8]
					2.
					a=[1, 2, 3, 4, 5, 6]
					一行代码实现对a中的偶数位置的元素进行加3后，组成的新列表

		运算
			+  生成了一个新的列表存这两个列表的和
			+= 效果与extend()一样，向原列表追加一个新元素，在原有列表上增加
			*

		列表嵌套：
			多维列表: [ [1, 2, 3], [4, 5, 6] ]
			zip函数
				它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。
				若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同

		列表去重：
			方式一：循环原始列表，创建新列表
			方式二：利用Set
		类型转换
			其他对象转列表
				list(str)
				eval(str)
			列表转字符串
				''.join(list)
				str(list) 
			列表转元祖
				tuple(list)

		列表嵌套:
			zip()  --内建函数
				它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组）
			*与dic() 连用，完成list组合成字典

		Set介绍
			集合类型--无序不重复元素集
				创建
					set()
				如何访问set中的值

				操作
					添加一项 s.add('x') 
					删除一项 s.remove('H')  
					弹出 	 s.pop()  
					清空	 s.clear()  

		练习：利用一行代码，把[1,2,3,1,2,3] 中的重复元素剔除。至少写出两种方式
				1.利用字典的key
				2.利用set
-----------------------------------------------------------------------------------------------------------------------
知识块10：字典

	# 字典是可变类型，
	# 字典中的数据是无序的
	# 一个字典条目的语法是 键:值
	# 任何不可变数据类型都可以作为条目的键（常用字符串和数字）
		创建
			{ } 、dict(key1=value1,key2=value2...)
				键必须独一无二，值不必
				如果键重复存入，会被覆盖
		访问数据项
			通过key
				dic[key]
				如果key不存在，报KeyError
		更新数据项
			dic[key] = value
			如果key不存在，就是新增数据项
		删除数据项
			del dic[key]  删除键是'key'的条目
			del dict      删除词典
		字典方法
			判断key存在
				*has_key(key)
				*in 、not in

			dic.pop(key)
				删除键key的项并返回key对应的 value值
				如果key不存在，报错

			*dict.keys() 返回一个包含字典所有KEY的列表

			*dict.values() 返回一个包含字典所有value的列表

			*dict.items() 返回一个包含所有（键，值）元祖的列表

			dict.clear() 删除字典中的所有项或元素

			dict.copy() 返回一个字典浅拷贝的副本

			*dict.fromkeys(seq, val=None) 创建并返回一个新字典，以seq中的元素做该字典的键，val做该字典中所有键对应的初始值（默认为None）

			dict.get(key, default = None) 返回字典中key对应的值，若key不存在字典中，则返回default的值（default默认为None）

			dict.update(bdict) 将字典bdict的键值对添加到字典adict中
				key存在，就更新value。key不存在就新增数据项

		运算
			字典不支持拼接和重复操作符（+，*）
			字典的比较操作
				长度等、键等、值等
		迭代
			遍历字典的key
				for key in adict.keys():print key

			遍历字典的value
				for value in adict.values(): print value

			遍历字典的项
				for item in adict.items():print item

			遍历字典的key-value
				for key, value in adict.items(): print 'key=%s, value=%s' %(key, value) 

			迭代器
				iter()函数可以将可迭代对象，变成迭代器
				迭代器有next()方法返回下一项，当没有值时，抛出StopIteration错误
				dict.iteritems()、dict.iterkeys()、dict.itervalues() 	
					与它们对应的非迭代方法一样，不同的是它们返回一个迭代子，而不是一个列表；
		排序
			sorted(dic,value,reverse)

    			dic为可以迭代的对象，value 为排序的对象（这里指键或键值）
    			reverse：注明升序还是降序，True--降序，False--升序（默认）
    			键排序
    			    --sorted(dict.keys())
    			    --sorted(dict.items(), key=lambda item:item[0])
    			值排序
    			    --sorted(dict.values())
    			    --sorted(dict.items(), key=lambda item:item[1])

			*collections：OrderedDict
				OrderedDict的Key会按照插入的顺序排列，不是Key本身排序

		类型转换
			其他类型转字典：
				字符串：eval(str)
				列表：
					二维列表转换
						手动构造
						利用zip

			字典转列表：
				list(dic) == dict.keys()
				dict.keys() dict.values()
			字典转元组：
				tuple(dic) -- 只包含key值
			字典转字符串：
				str(dic)

		练习：
			1.对a进行排序得到列表b，然后把a和b按元素顺序构造一个字典d

-----------------------------------------------------------------------------------------------------------------------
知识块11：函数--实现代码的复用

		内置函数
			# 匿名函数,lambda
				def func(x,y):
					return x+y
				func = lambda x,y:x+y

			# 1、绝对值：abs(-1)
			# 2、最大最小值：max([1,2,3])、min([1,2,3])，对序列进行操作
			# 3、序列长度：len('abc')、len([1,2,3])、len((1,2,3))
			# 4、取模：divmod(5,2)//(2,1)得到一个元组
			# 5、乘方：pow(2,3,4)//2**3/4
			# 6、浮点数：round(3.1415926,2)//3.14 四舍五入
			# 7、类型转换函数：int()、str()....
			# 8、比较函数cmp()


		创建函数
			def 函数名(参数列表)：
				函数语句

				函数的命名规则：一个单词直接小写
					# 多个单词，每个单词小写，以下划线分隔

				文档化说明
					函数首行加 ''  或 ''' '''
						使用函数名.__doc__属性 可以查看函数文档
						help(函数名)

				callable(函数名) --判断函数是否可以被调用

				pass--占位
						
		参数
			默认参数
				默认值最好是不可变数据类型

			增加参数名

			可变参数
				传入的参数个数是可变的

				*params
					在函数内部，参数numbers接收到的是一个tuple或list
					在函数调用时，可以一个一个的传，也可以传list或tuple --*params

				**params
					在函数内部，参数numbers接收到的是一个dict
					在函数调用时:
						可以一个一个的传 key=value
						也可以传dict --**params

			**参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数

			作用域	
				根据变量声明的位置的不同，变量存在不同的作用域：全局，局部
					局部--函数的变量，超出函数外就无效了
					全局--作用于整个程序 global
						函数内部也可以定义全局变量
							注意：必须要先调用函数，函数体中定义的全局变量才能生效

		关于返回
			见到return 函数就结束
			不写return无返回--None
			只写return 返回None
			返回多个值--实际返回的是元祖

		递归
			如果一个函数在内部调用自身，这个函数叫做递归函数
			练习：求一个数n的阶乘
			递归调用的次数过多，会导致栈溢出
				尾递归优化 --return语句不能包含表达式

		函数式编程--函数的参数是函数
			高阶函数
				def fun(x, y, f):
					pass

				def f():
					pass

			map():将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回
				  函数接收两个参数，一个是函数，一个是序列
				  应用：并行遍历--序列合并
			reduce():把一个函数作用在一个序列上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算
					 reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

			filter():“筛选”函数
					接收一个函数和一个序列
					把传入的函数依次作用于每个元素，根据返回值是True还是False决定保留还是丢弃该元素

		练习：
				0.写一个函数，用递归的方法实现快速排序,按照升序排列

				1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']

				2.Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积

-----------------------------------------------------------------------------------------------------------------------
知识块12：类和对象
	类是对某一类具有共同特点的事物的抽象,类的具体实例叫做对象
		学生是类，张三是一个具体的学生就是 学生类的实例(Instance)，也叫学生对象

	类的定义：
		class 类名(父类)：
			类实体	
			*类名：每个单词的首字母大写

		构造函数（初始化函数） __init__(self)
			作用：python在创建类的实例的时候，会调用这个类的__init__()方法
				  初始化数据

			self：创建的实例自身(存储当前对象的地址)
				  所有的类方法都第一个参数默认是self，但是调用的时候不需要传值

		类的属性：变量
			成员变量--属于实例的变量
				每次实例化就创建，实例结束就销毁
					*一般是在__init__方法中通过self完成 定义
					*类内部：通过self访问，类外部：通过实例名访问(一般需要封装getter)

			类变量
				属于类自己的变量（保存在内存），每次被构造的时候，拷贝一个副本给对象
					*在类起始处统一定义
					*通过类名或实例来访问
						通过对象的修改只对当前类生效，通过类名的修改才能改变值
			访问限制
				私有变量：__变量名
					python使用的是名字重整技术，改变了私有变量的值：_类名__变量名

			专属变量
				__xx__

		类的操作：方法
			成员（实例）方法
				定义：必须带有参数self
					内部：可以访问成员变量、类变量(self或类名)、成员方法(self)、类方法(self或类名)
					外部：通过类实例调用
			类方法
				定义：必须带有@classmethod、和cls参数
					内部：可以访问类变量、类方法
					外部：通过类实例或类名调用

			静态方法
				定义：必须带有@staticmethod
				内部：如果静态方法调用类方法或属性事，只能直接类名.属性名或类名.方法名
				外部：通过类实例或类名调用

			私有方法:
				__xx()

			特殊方法：
				__xx__() 代表一定的协议，相当于Java中的接口方法

					__str__()与__repr__() 
						__str__()  --让class作用于print()函数
						__repr__() --返回程序开发者看到的字符串

					__len__() --让class作用于len()函数

					__iter__() --让class具有可迭代的属性,返回值必须是对象自己
						next():每一次for循环都调用该方法

					__getitem__() --让class作用于索引方式 

					__getattr__()
						当调用不存在的属性时，会试图调用此方法，来尝试获得属性

						练习：链式调用
							慧测网公共api服务的基础域名：http://api.huice.server
								http://api.server/user/login
								http://api.server/user/list
							提供一个URL类，动态添加属性，输出成格式化地址

					动态绑定方法：
						给实例绑定方法：
							from types import MethodType
							实例变量.MethodType(方法名, 实例变量, 类名)
						给类绑定方法：
							类名.MethodType(方法名, None, 类名)

	封装
		利用列表实现数据结构--栈
		理解setter和getter的作用
			1.初始化函数，传入栈的极限大小
			2.提供一个栈和一个压栈的方法
			3.提供一个获取栈极限大小的方法
			4.其他方法私有--判断栈是否到达极限，栈是否为空

        @property --把一个方法变成属性调用
          用法：
          	定义getter-- 函数名与属性名一致，加@property
          	定义setter-- 函数名与属性名一致，加@函数名.setter 

	继承和多态		
		继承		
			方法覆盖(重写)
			多态--对扩展开放，对修改关闭
				1.当我们需要传入一个对象时，我们可以不传入具体的类型，而传入一个抽象的概念---父类对象
				2.这样，在程序实际运行时，可以动态绑定传入的类型
			    3.因为都有共同的父类，所以一定有共同的方法。使用时，内部使用时，调用共有的方法就可以
			isinstance()方法

			多重继承
  				(class1, class2, class3)  --class1优先

-----------------------------------------------------------------------------------------------------------------------
知识块13：异常
	在程序运行过程中，总会遇到各种各样的错误
		有的错误是程序编写有问题造成的
		还有一类错误是完全无法在程序运行过程中预测的

	调试时我们关心
		什么类型的错误？
		在哪儿出错的？
		为什么出错？

	抛出的异常也是对象
		异常的分类
			系统定义的异常
				BaseException 所有异常的基类	
					Exception 常规错误的基类
						StandardError 所有的内建标准异常的基类
							ImportError  导入模块错误
							ArithmeticError 所有数值计算错误的基类
								FloatingPointError 浮点计算错误
							AssertionError  断言语句失败
							AttributeError  对象没有这个属性
						Warning 警告的基类
			自定义异常
				创建类，继承相应系统异常即可
					选择性重写 __init__ 和  __str__
	异常处理

		捕获 try except finally
			执行顺序：
				当我们认为某些代码可能会出错时，就可以用try来运行这段代码
				如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块
				执行完except后，如果有finally语句块，则执行finally语句块

			except：
				1.可以一次捕捉多个异常 (exception1, exception2)
				2.多个except：
					不要求从小到大捕捉
				3.可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句
				4.e代表当前异常的实例 print可以显示错误信息
				5.except :可以捕获所有异常

		抛出
			如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出
			raise 异常类名 (错误信息)

	练习：
		1.编写一个计算减法的方法，当第一个数小于第二个数时，抛出“被减数不能小于减数"的异常
		2.接收键盘输入的两个数字，进行加法运算，当输入的有非数字时，通过异常处理机制使程序正常运行
		3.创建一个用户注册服务，其中有一个register方法。当用户名小于6位时，抛出自定义异常
		  系统异常NameError的子类异常IllegalNameError
-----------------------------------------------------------------------------------------------------------------------
知识块14：模块
	在Python中，一个文件就称之为一个模块（Module）
		可以作为module的文件类型有: ".py"、".pyo"、".pyc"、".pyd"、".so"、".dll"

	导入--完成代码的重复使用（属性，方法）
		import xxx
			导入xxx模块后，我们就有了变量xxx指向该模块，利用这个变量，就可以访问xxx模块的所有功能

		导入模块是用于定义的--定义变量、函数
			首次导入会运行代码，再次导入不会运行。除非使用reload(模块名)函数
			如果不想在导入的时候加载的代码（只在模块单独运行时执行）
				使用 if __name__ == '__main__' 

		解释器如何找到的模块？
			1.首先在当前目录查找 --将模块拷贝到当前路径?
			2.当前脚本指定的sys.path   --python搜索模块的路径集合
			3.环境变量 --PYTHONPATH
			4.安装设置相关的默认路径
				built-in --内建模块
				C:\Python27\Lib --所有python类库的总目录
					标准库模块
						email、json、csv、httplib、io....
					site-packages --第三方包
			5.找到名字符合的就停止

			如果我们要引入自定义的模块：
				0.在一个目录中直接import名称
					如果是子目录，也可以直接调用
					如果是上级或同级目录，不能直接import

				1.添加自己的搜索目录，有两种方法：
					第一种是直接修改sys.path，添加要搜索的目录：
						import sys
						sys.path.append('/Users/my_py_scripts')
						但在退出python环境后自己添加的路径就会自动消失
					第二种方法是设置环境变量PYTHONPATH
				2.将包放到python安装目录的Lib下或sitepackage下（不推荐）

		包（Package）存放模块	--将多个.py文件组织起来，以便在外部统一调用
			完整的模块名 = 包名.子包名.模块名
			__init__.py
				每一个包，都有一个__init__.py 文件，否则就是普通目录
					__init__.py可以为空，也可以设置相应的内容
						导入包之前会优先执行__init__.py中的内容
							from A import *
							__init__.py
							__all__ = ['module_13', 'module_12']
							
		使用别名
			import xxx as X
				应用：统一变量名
					例1：
						try:
	    					import cStringIO as StringIO
						except ImportError:
	    					import StringIO

    				例2：
						try:
	    					import json 	# python >= 2.6
						except ImportError:
	    					import simplejson as json # python <= 2.5
 		使用from
 			从一个包中导入部分模块
 				from selenium import webdriver
 			从一个模块中导入部分内容
 				from A import a, b, c --abc可以是类，也可以是方法
 				from A import * --从A中导入 所有 __all__属性列表中定义的，允许导入的内容

		安装第三方模块
			源码安装
				下载源码包，解压
				python setup.py install

			easy_install和pip
				安装配置easy_install
					下载ez_setup.py
						python ez.setup.py
				用easy_install安装应用
					
				安装配置pip

					用pip安装应用
						pip instal
						要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索--pypi.python.org
						指定版本 ： 包名==版本号

						pip list
						查看所有已安装的包和版本

						pip uninstall
						卸载包
-----------------------------------------------------------------------------------------------------------------------
知识块15：常用标准库以及第三方库
	
	sys --系统环境相关
		sys.argv --返回一个命令行参数列表
		sys.path --模块的搜索路径列表
		sys.modules --包含所有加载模块的信息. import 语句在从磁盘导入内容之前会先检查这个字典
		sys.exit(n) --0是正常退出，其他为异常	

		练习：编写一个dump函数，接受一个模块名
			如果模块为系统内建模块，输出built-in
			如果模块不是内建模块，输出模块所在的路径
			如果输入的模块名不正确，输出模块名无效

	*os --对目录或文件操作
		变量类
			os.environ --以字典形式返回系统环境变量

		函数类
			*os.system(command) --执行命令行（运行外部程序），不能存储结果
			os.startfile(path) --windows特有，模拟双击打开文件
							     mac/linux-- subprocess.Popen(path)
			popen(command)  --执行命令行，并返回一个文件对象
			os.getpid()	    --返回当前进程ID

			操作路径：
				*os.getcwd()	        --得到当前工作的目录
				os.listdir()        --指定目录下所有的文件和目录名
				os.mkdir()          --创建目录,已存在报错
				os.makedirs()		--创建多级目录,任何一级名称已存在都会报错
				os.rmdir()		    --删除指定目录,只能是空目录
				os.removdirs()		--删除多级目录,只能是空目录
				*os.chdir()          --改变目录到指定目录
				os.path.isfile()    --判断指定对象是否为文件。是返回True,否则False
				os.path.isdir()     --判断指定对象是否为目录。是True,否则False
				os.path.exists()    --检验指定的对象(文件)是否存在
				os.path.split()     --返回路径的目录和文件名
				os.path.join(path, name)  --连接目录和文件名
				os.path.dirname(path)     --返回path中的文件夹部
				os.path.basename(path)    --返回文件名
				os.path.abspath()         --获得绝对路径

				练习：
					report文件夹中，是所有自动化测试报告的存放路径。取出本次生成的报告文件名
						1.报告以时间戳命名
						2.报告不以时间戳命名

			操作文件：
					os.path.getmtime(path) --文件或文件夹的最后修改时间，从新纪元到访问时的秒数
					os.path.getsize(path)  --文件或文件夹的大小，若是文件夹返回0
					os.remove(path)		   --移除文件	
					os.rename(old, new)	   --重命名文件或目录	
					os.chown(path, uid, gid)	--改变文件或目录所有者	   
					os.chmod(path, mode)	--改变文件访问权限	
											os.chmod('/home/user/c/a.tar.gz', 0777)

	*shutil --高级的 文件、文件夹、压缩包 处理模块
		shutil.copyfile(src, dst)  --拷贝文件,如果当前的dst已存在的话就会被覆盖掉
		shutil.copy(src, dst)      --拷贝文件和权限
		shutil.copytree(src, dst, symlinks=False, ignore=None)  --递归的去拷贝文件
		shutil.rmtree(src) 		   --递归删除一个目录以及目录内的所有内容

	time  --提供了各种操作时间值
		time.time()  获取当前时间时间戳--秒
		time.ctime(seconds)	根据秒数取时间戳--美式时间格式
		time.asctime([tuple]) 根据时间元祖，获取时间戳--美式时间格式
		time.localtime(seconds)  将秒数转换成一个时间值元祖
		time.mktime(tuple)	将一个时间值元祖转换成秒数
		time.sleep(seconds)	延迟执行给定的秒数 
		*time.strftime(format[,tuple_time])
		    根据传入的格式化字符串，将tuple时间格式化为指定的格式
			tuple_time可以不传，不传返回当前时间格式化后的结果
			#  python中时间日期格式化符号:
				# %y     两位数的年份表示（00-99）
				# %Y     四位数的年份表示（000-9999）
				# %m     月份（01-12）
				# %d     月内中的一天（0-31）
				# %H     24小时制小时数（0-23）
				# %I     12小时制小时数（01-12） 
				# %M     分钟数（00=59）
				# %S     秒（00-59）
		time.strptime(string, format)
				# 传入的时间为字符串
				# 按照传入的format解析字符串时间为tuple格式的时间

		更多日期和时间的算法支持，详见 datetime库
					
	random  --生成随机数
		random.uniform(a,b)  返回a和b范围内的随机实数 [a,b)
		random.randint(a,b)	返回整数a和b范围内数字  [a,b]
		random.random()	返回随机数，它在0和1范围内(不包括1)
		random.randrange(start, stop[, step])	返回整数范围的随机数
		random.sample(array, x)	从集合或元祖中返回随机x个元素 --集合形式
		random.shuffle(array)   给指定的序列进行随机移位

		练习：
			1.随机输出2017年的当前时间之前的一个时间点，格式为：2017-05-01_13:59:06
			2.用python脚本，写一个斗地主的发牌程序
				3个人每人17张，三张底牌归地主所有
				要求：函数返回一个字典，{地主：[], 农民1:[], 农民2:[]}

	*正则表达式和re模块
	判断一个字符串的格式，提取字符串的内容
	正则表达式是一种用来匹配字符串的强有力的武器
		用一种描述性的语言来给字符串定义一个规则：
			凡是符合规则的字符串，我们就认为它“匹配”了
			否则，该字符串就是不合法的

		语法规则
			普通字符串:
				大小写字母、数字、部分标点符号
				被转义过的特殊字符
				直接给出字符，就是精确匹配

			特殊字符：
						1. '.'表示任意字符
						2. 不定长
							*表示任意个字符（包括0个）
							+表示至少一个字符
							?表示0个或1个字符
							{}表示重复次数
								ab{2}  ab{2,}  ab{3,5}
						3.更精确地匹配，可以用[]表示范围
							'[]'表示字符组，匹配其中的任意一个    --数字[0-9] , 字母[a-zA-Z]
    							[0-9a-zA-Z\_]
    							可以匹配一个数字、字母或者下划线；
    							[0-9a-zA-Z\_]+ 
    							可以匹配至少由一个数字、字母或者下划线组成的字符串
    							[a-zA-Z\_][0-9a-zA-Z\_]*
    							可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串
    							[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}
    							更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。
						4.'^'和'$'--开始, 结束
							"^The"：表示所有以"The"开始的字符串
							"of despair$"：表示所以以"of despair"结尾的字符串
							^python$: 表示整行内容是python
						5.被转义过的普通字符
							\d --一个数字  
							\D --非数字
							\w --表示字母、数字、下划线中的任意一个字符
							\W --非单词字符
							\s --空格

						6.分组()
							^(\d{3})-(\d{3,8})$

						7.贪婪匹配
							102300    
								^(\d+)(0*)$ 
								^(\d+?)(0*)$
		re模块
			在Python中使用正则表达式。Python提供re模块，包含所有正则表达式的功能
			(因为python中也使用\，所以构造正则表达式时，在表达式字符串前面一定要加r)

				re.match(r'正则表达式', '待检查的文本字符串')  --从开始位置匹配，找到一个
					匹配到返回一个Match对象,匹配不到返回None
						如果表达式中使用了分组，可以用Match对象的group()方法提取出子串
							group(0)永远是原始字符串
							group(1)、group(2)  --表示第1、2、……个子串

				re.search(r'正则表达式', '待检查的文本字符串') --检索全文,找到一个
				re.split(r'正则表达式', '待检查的文本字符串')  --会根据模式的匹配项来分割字符串
				re.findall(r'正则表达式', '待检查的文本字符串') --找到所有，返回一个列表

		练习：
			验证邮箱格式
			获得一个URL地址的扩展名
			获取页面上的所有超链接

	*json
		JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。
 			对象表示为键值对
			数据由逗号分隔
			花括号保存对象
			方括号保存数组
			JSON最常用的格式是对象的 键值对。例如下面这样：
				key只能是string, value可以是 object、array、string、number、true/false、null
					{"firstName": "Brett", "lastName": "McLaughlin"}
					{"name":["Brett", "McLaughlin"], "age":18}
					{"name":{"firstName": "Brett", "lastName": "McLaughlin"}, "age":18}
					{"name":[{"firstName": "Brett"}, {"lastName": "McLaughlin"}], "age":18}

		序列化--无序（无格式）--> 有序（有格式）
		--python对象转换成json对象
			dumps() --字典转json字符串
				value值转换后对应的值
					Python 				JSON
					dict 				object
					list, tuple 		array
					str, unicode 		string
					int, long, float 	number
					True 				true
					False 				false
					None 				null
				参数
					ensure_ascii  --序列化时,是否采用ascii编码(默认值为True)
						应用：打印字典，不显示16进制码
					sort_keys     --控制是否按照字典中的key排序(默认值为False)
						应用：方便查看、比较
					indent		  --定义缩进大小(int类型)默认为None
						应用：可读性更强
					separators    --是一个元组，定义分隔符的类型 ( 默认为(',' , ':') )

					skipkeys      --跳过那些非string对象当作key的处理

					default  --指定序列化的转化函数, 转换非built-in的数据类型
						应用：一般自定义对象, 想直接转换成json

			dump() --文件转jsonn字符串

		反序列化--有序（有格式）--> 无序（无格式）
		--json对象转换成python其他对象
			loads() --json对象转字典
				# 标准的json格式是key和value都以双引号来包裹
				参数
					encoding
					object_hook --指定转化函数
						应用：json字符串直接反序列成一般自定义对象

			load() --json对象转文件

		练习：
			{"xAxis":["business_autoFans_J","autoAX","autoAX_admin"],
			"yAxis":
				[
					{"2016_08":[14,7,16],"2016_09":[0,13,12],"2016_10":[24,15,7]},
					{"2016_08":[0,0,5],"2016_09":[32,31,17],"2016_10":[22,22,9]}, {"2016_08":[0,7,10],"2016_09":[0,0,0],"2016_10":[5,13,2]}
				]
			}


			提供一个函数，通过传入的月份，查询该月的bug总数
			返回数据格式：字典{项目名:bug总数}
	
	excel 
		读取excel  xlrd	--第三方库
			1.打开工作薄(workbook)
				Book = open_workbook(path)
			2.打开sheet 页
				Book.sheets() -- list[Sheet]
				Book.sheet_by_name(name)  --Sheet
				Book.sheet_by_index(index) --Sheet

			3.获取值
				整行和整列的值：
					sheet.row_values(index)
         			sheet.col_values(index)

         		获取行数和列数
         			sheet.nrows
        			sheet.ncols

        		获取单元格
        			sheet.cell(x,y).value
        			sheet.cell_value(x,y)
        			sheet.row(0)[1].value
					sheet.col(1)[0].value

		写入excel  xlwt
			xlwt.Workbook()
			wkbw.add_sheet()
			sheet.write(0,1,'hello python')
			workbook.save('D:\\test\\test01.xls')

		练习：从用户上传的excel文件中，读取多个项目，每个项目的bug汇总情况。
			  拼装成json报文，发送个服务端接口，存储到数据库
			  
	xml
		1.使用xml.dom --文件对象模型（Document Object Model，简称DOM）
			原理：一个 DOM 的解析器在解析一个 XML
			 	  文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里
			使用：xml.dom.minidom
					1.文档--tree--Document对象(root)
						parse(file)--documentElement
					2.调用Document对象的相关方法查询到具体对象
					    getElementById getElementsByTagName childNodes parentNode
					3.获取对象text 或者获取对象属性
					    nodeValue(.data)  --注意只有textNode对象才能获取text。
					    	firstChild\childNodes返回textNode对象
					    getAttribute 
					4.设置（修改、新增）对象text或属性
					    setAttribute writexml

		2.使用ElementTree
			使用：xml.etree.ElementTree  
				1.加载xml文件--加载XML文件共有2种方法,一是加载指定字符串，二是加载指定文件
					root = ElementTree.fromstring(text)  
					root = ElementTree.parse("D:/test.xml") 

				2.获取element的方法
					a) 通过getiterator   --Element
					b) 通过 getchildren
					c) find方法 (支持部分xpath语法)
					d) findall方法 (支持部分xpath语法)

				3.获取值、属性
					.text  
					.attrib['category']
					.tag
					.set

	requests库的使用
		requests是python的一个HTTP客户端库，跟urllib，urllib2类似，那为什么要用requests而不用urllib2呢？官方文档中是这样说明的：
			“python的标准库urllib2提供了大部分需要的HTTP功能，但是API太逆天了，一个简单的功能就需要一大堆代码。”

		1. 安装
			https://pypi.python.org/pypi/requests
			api：http://cn.python-requests.org/zh_CN/latest/
			pip install requests

		2.import requests
		
		3.发送请求
			requests.get('http://www.baidu.com')
			配置url参数
				 params 关键字参数，以一个字典来提供这些参数
				 payload = {'key1': 'value1', 'key2': 'value2'}
				 requests.get("http://httpbin.org/get", params=payload)

			requests.post(url)
				表单提交
					data传入字典
						payload = {'key1': 'value1', 'key2': 'value2'}
						requests.post("http://httpbin.org/post", data=payload)

				x-www-form-urlencoded形式
					headers增加配置  Content-Type:application/x-www-form-urlencoded
					data传入字典

				raw（文本）提交
					字符串形式\xml形式
						方式一：普通字符串(xml字符串)
							payload = '<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" '
							r = requests.post(url, data=payload)
						方式二：字典转字符串
							payload = {'some': 'data'}
							r = requests.post(url, data=json.dumps(payload))	

					json形式
						payload = {'some': 'data'}
						r = requests.post(url, json=payload)

								
				二进制形式（文件）提交
					files参数
						files = {'file': open('report.xls', 'rb')}
						requests.post(url, files=files)

			定制请求头	
				headers 字典
					url = 'https://api.github.com/some/endpoint'
					headers = {'user-agent': 'my-app/0.0.1'}
					requests.get(url, headers=headers)

			添加Cookie
				cookies 字典
					cookies = dict(cookies_are='working')
					cookies ={'cookies_are':'working'}
					requests.get(url, cookies=cookies)
			超时
				requests.get('http://github.com', timeout=0.001)
				timeout 仅对连接过程有效，与响应体的下载无关
				超时则抛出requests.exceptions.Timeout

		4.接收请求
			requests的get和post方法返回值都是Response对象，其存储了服务器响应的内容	

				响应状态码:response.status_code
					response.raise_for_status() #失败请求(非200响应)抛出异常
				响应头:response.headers--字典

				Cookie: response.cookies--字典

				响应体：response.text
					内容编码格式问题
						Requests 会基于 HTTP 响应头对响应的编码作出有根据的推测
						response.encoding = 'utf-8' 指定编码格式，之后再调用response.text显示的编码格式就是设置后的

				响应中的字节内容(二进制)：response.content

				解析响应
					response.json
-----------------------------------------------------------------------------------------------------------------------
知识块16：IO以及文件处理
	程序和运行时数据是在内存中驻留,涉及到数据交换的地方，通常是磁盘、网络等
	从磁盘读取文件到内存，就是Input操作。反过来，把数据写到磁盘文件里，就是一个Output操作
	IO编程中，Stream（流）是一个很重要的概念
	操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用

	文件操作
		请求操作系统打开一个文件对象（通常称为文件描述符），然后通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）

		--open()函数

		读文件
			open(path, mode) --返回 file对象
				mode  --Python文件打开方式
					# r ： 以只读方式打开文件，文件不存在则出错  抛出IOError
					# w：  以只写方式打开文件，文件存在则清空，不存在则建立
					# a：  以追加只写的方式打开，不清空文件，在文件末尾加入内容
					# w+   读写权限打开文件，只要打开就会清空文件,文件不存在则创建文件
					# r+   读写权限打开文件，如果写入了数据则会清空文件,文件不存在出错
					# a+   读写权限打开文件，不清空文件,在文件末尾新增写入的内容，文件不存在创建文件
					# b    表示要读写二进制数据

			read(size) : 一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示
						 返回文件中剩余的文本组成的多行字符串

			readline() ：从文本中读取一行文本，该函数返回一行的文本字符串，包括换行符“\n”
			close() : 方法关闭文件。关闭后再次读取会报错
			readlines() : 一次读取所有内容并按行返回list

			with语句
				with context_expression [as target(s)]:
    				with-body
    			1.上下文管理器对象必须实现__enter__() 和 __exit__()方法
    			2.context_expression语句执行，返回一个上下文管理器对象
    			3.执行该对象的__enter__()方法，返回的对象赋值给as后的变量
    			4.执行完语句体之后会执行 上下文管理器对象的__exit__() 方法
    			5.文件和线程对象都是上下文管理器对象。file实现__exit__() 方法，关闭流

				with open('/path/to/file', 'r') as f:
    				print f.read()

    		读取二进制文件 :
    			f = open('demo.jpg', 'rb')
				f.read()

			用fileinput 来进行迭代
				import fileinput
				for line in fileinput.input(filename):
    				print(line)
    			fileinput.close()  

    	写文件
    		写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件
    			write(str)
    			writelines(list) 写入一个序列类型
    			flush()一般的文件流操作都包含缓冲机制，write方法并不直接将数据写入文件，而是先写入内存中特定的缓冲区
				flush方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区

    	练习：
    		1.不借用shutil模块，完成对一个图片文件test.png的备份test_bak.png
    		2.实现目录递归遍历，查找以.py结尾的文件，并将文件绝对路径存入log.txt文件
-----------------------------------------------------------------------------------------------------------------------

作业：
	1.用python语言编写一个程序，判断一个年份是否是闰年
	2. for循环输出九九乘法表
	3.统计一篇英文文章每个单词的出现频率，并返回出现频率最高的前5个单词及其出现次数(字典形式)
A small sample of texts from Project Gutenberg appears in the NLTK corpus collection. However, you may be interested in analyzing other texts from Project Gutenberg. You can browse the catalog of 25,000 free online books at http://www.gutenberg.org/catalog/, and obtain a URL to an ASCII text file. Although 90% of the texts in Project Gutenberg are in English, it includes material in over 50 other languages, including Catalan, Chinese, Dutch, Finnish, French, German, Italian